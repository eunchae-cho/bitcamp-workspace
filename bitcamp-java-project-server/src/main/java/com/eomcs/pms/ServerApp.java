/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.eomcs.pms;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import com.eomcs.context.AppContextListener;
import com.eomcs.pms.handler.Command;
import com.eomcs.pms.listener.AppInitListener;
import com.eomcs.pms.listener.DataHandlerListener;
import com.eomcs.pms.listener.RequestMappingListener;

public class ServerApp {

	static boolean stop = false;

	ExecutorService threadPool = Executors.newCachedThreadPool();

	static Map<String, Object> context = new Hashtable<>();
	List<AppContextListener> listeners = new ArrayList<>();

	public void addApplicationContextListener(AppContextListener listener) {
		listeners.add(listener);
	}

	public void removeApplicationContextListener(AppContextListener listener) {
		listeners.remove(listener);
	}

	private void notifyAppContextListenerOnServiceStarted() {
		for (AppContextListener listener : listeners) {
			listener.contextInitialized(context);
		}
	}

	private void notifyAppContextListenerOnServiceStopped() {
		for (AppContextListener listener : listeners) {
			listener.contextDestoryed(context);
		}
	}

	public void service(int port) {

		notifyAppContextListenerOnServiceStarted();

		try (ServerSocket ss = new ServerSocket(port)) {
			System.out.println("서버 실행 중");

			while (true) {
				Socket clientSocket = ss.accept();

				if (stop) {
					break;
				}

				threadPool.execute(() -> handleClient(clientSocket));
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

		notifyAppContextListenerOnServiceStopped();
		
		threadPool.shutdown();

		try {
			if (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) {
				System.out.println("아직 종료 하지 않은 작업이 있음");
				System.out.println("남아 있는 작업의 강제 종료 시도");
				threadPool.shutdownNow();
				if (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) {
					System.out.println("아직 종료 하지 않은 작업이 있음");
				} else {
					System.out.println("모든 작업 종료");
				}
			}
		} catch (Exception e) {
		}
	}

	public static void main(String[] args) {
		ServerApp serverApp = new ServerApp();
		serverApp.addApplicationContextListener(new AppInitListener());
		serverApp.addApplicationContextListener(new DataHandlerListener());
		serverApp.addApplicationContextListener(new RequestMappingListener());
		serverApp.service(8888);
	}

	private static void handleClient(Socket clientSocket) {
		InetAddress address = clientSocket.getInetAddress();
		System.out.printf("클라이언트(%s)가 연결되었습니다.\n", address.getHostAddress());

		try (Socket socket = clientSocket;
				PrintWriter out = new PrintWriter(socket.getOutputStream());
				BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {

			String request = in.readLine();

			if (request.equalsIgnoreCase("stop")) {
				stop = true;
				out.println("서버를 종료하는 중입니다.");
				out.println();
				out.flush();
				return;
			}

			Command command = (Command) context.get(request);
			if (command != null) {
				command.execute(out, in);
			} else {
				out.println("해당 명령을 처리할 수 없습니다.");
			}
			out.println();
			out.flush();

			// 이 메소드에 예외가 발생시 main으로 에러를 위임하게 되면(throws Exception 선언) 그 쪽의 catch문에서
			// 예외를 잡게 된다.
			// 사실 두 가지 방법이 있다.
			// 1. 메소드 안에서 try catch 사용하여 처리
			// 2. throws Exception 써서 던진 곳에서 처리
		} catch (Exception e) {
			System.out.printf("클라이언트와 대화 도중 예외 발생 - %s\n", e.getMessage());
		}

		System.out.printf("클라이언트(%s)와의 연결을 끊었습니다.\n", address.getHostAddress());
	}

}
