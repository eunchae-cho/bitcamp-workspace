package com.eomcs.basic.ex05;

//# 비트 이동 연산자 : >>, >>>, <<
//
public class Exam0410 {
  public static void main(String[] args) {
    // << 비트 이동 연산자 사용법
    // - 왼쪽으로 비트를 이동시킨다.
    // - 오른 쪽 빈자리는 0으로 채운다.
    // - 왼쪽 경계를 넘어간 비트는 자른다.
    //
    int i = 1;
    //     00000000 00000000 00000000 00000001 = 1

    System.out.println(i << 1);
    //   0|00000000 00000000 00000000 0000001x      비어있는 공간은 0으로 채움
    //     00000000 00000000 00000000 00000010 = 2

    System.out.println(i << 2);
    //  00|00000000 00000000 00000000 000001xx
    //     00000000 00000000 00000000 00000100 = 4

    System.out.println(i << 3);
    // 000|00000000 00000000 00000000 00001xxx
    //     00000000 00000000 00000000 00001000 = 8

    System.out.println(i << 4);
    //0000|00000000 00000000 00000000 0001xxxx
    //     00000000 00000000 00000000 00010000 = 16

    i = 0b0000_1011; // 11
    System.out.println(i << 1); // 0001011x => 00010110 => 22
    System.out.println(i << 2); // 001011xx => 00101100 => 44
    System.out.println(i << 3); // 01011xxx => 01011000 => 88

    // 왼쪽 이동
    // - 1비트 이동은 곱하기 2 한 것과 같은 효과를 준다.
    // - 값을 배수로 증가시킬 때 곱하기 연산을 하는 것 보다
    //   왼쪽 비트 이동 연산을 하는 것이 빠르기 때문에
    //   실무에서는 이 비트 이동 연산을 자주 사용한다.
    // - 비트 이동 => '2**이동비트'를 곱한 것과 같은 결과를 만든다.
    
    // 영어는 1 바이트, 한글은 2바이트, 영어+한글은 2바이트
    // 비트연산자(>>)를 이용해 /2^비트수 를 사용 => 처리속도가 빠름
    
    String s1 = "abc";
    String s2 = "가나다";
    String s3 = "a가b";
    System.out.println(s1.length());
    System.out.println(s2.length());
    System.out.println(s3.length());
    // ctrl을 보면 String 소스 관련 파일이 나오는데 거기서 String에 대한 length를 
    // /2 한게 아니라 비트연산자 >>를 사용해 입력됨
    
  }
}

// 00000000 00000000 00000000 00001011 11
// 00000000 00000000 00000000 00010110 22
// 00000000 00000000 00000000 00101100 44
// 00000000 00000000 00000000 01011000 88



