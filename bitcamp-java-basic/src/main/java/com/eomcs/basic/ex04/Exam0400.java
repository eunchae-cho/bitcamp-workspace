// 변수의 종류


package com.eomcs.basic.ex04;

public class Exam0400 {
  public static void main(String[] args) {
    
    //정수
    byte b;
    short s;
    int i;
    long l;
    
    //부동 소수점
    float f;
    double d;
    
    //문자
    char c;
    
    //논리
    boolean bool;
    
    //레퍼런스
    String str;
    
    //변수의 메모리 크기
    //정수 리터럴은 기본이 4바이트이다.
    //원래 작은 메모리에 저장할 수 없지만
    //오른쪽의 값이 4바이트 정수 리터럴일 경우
    //메모리에 그 리터럴을 저장할 수 있다면 허락한다.
    b = -128;
    b = 127; 
    //b = -129;         메모리 초과 
    //b = 128;          메모리 초과
    
    //리터럴끼리의 연산 결과는 리터럴로 취급한다.
    b = 120 + 7;
    //b = 120 + 8;      리터럴끼리의 연산 결과는 리터럴
    b = 20 * 3;
    
    byte b2 = 20;
    // b = 100 + b2;    4바이트 리터럴끼리의 연산만 가능 이건 리터럴+변수 => 변수취급
    
    
    s = -32768;
    s = 32767;
    //s = -32769;
    //s = 32768
    
    i = -21_0000_0000;
    i = 21_0000_0000;
    //i = -22_0000_0000;
    //i = 22_0000_0000;
    
    l = -922_0000_0000_0000_0000L;
    l = 922_0000_0000_0000_0000L;
    //l = -923_0000_0000_0000_0000L;
    //l = 923_0000_0000_0000_0000L;
    
    b = 100;
    s = 100;
    i = 100;
    
    //b = 100L;             8바이트 리터럴이기 때문에 안됨
    //s = 100L;             4바이트 리터럴끼리일때만 가능
    //i = 100L;
    
    byte b3;
    b3 = b;
    //b3 = s;
    //b3 = l;
    
    short s2;
    s2 = b;
    s2 = s;
    //s2 = i;
    //s2 = l;
    
    int i2;
    i2 = b;
    i2 = i;
    i2 = s;
    //i2 = l;
    
    long l2;
    l2 = b;
    l2 = s;
    l2 = i;
    l2 = l;
    
    s = -32768;
    s = 32767;
    char c2;
    //c2 = -32768;              char 타입은 양수만 가능
    //c2 = 65536;               65535의 메모리 값을 갖고 있지만 유니코드만 가능
    
    //c2 = s;    
    //s = c2;
    
    
    f = 999.9999f;
    f = 9.999999f;
    f = 999999.9f;
    
    // 부동 소수점은 7자리까지의 숫자만 유효 
    // 그 이상의 자리수인 경우 잘린다.
    // 주의 :
    // 유효 자리수가 넘어간다고 에러가 나지 않는다
    // 값이 그냥 잘린다 (개발자들의 흔한 실수)
    f = 999.99994f;
    System.out.println(f);
    System.out.println("\n------------------------\n");
    
    float f1 = 1.234567f;
    float f2 = 12345.22f;
    float f3 = 92345.22f;
    float f4 = f1 + f2;         // float +float = 12346.45xx
    float f5 = f1 + f3;         // dx = 12346.45xx
    System.out.println(f1);
    System.out.println(f2);
    System.out.println(f3);
    System.out.println(f4);     // 자리수가 잘림 유효하지만 정확한 수가 아님
    System.out.println(f5);
    
    System.out.println("\n--- float => double ---\n");
    
    // 두 부동 소수점을 연산한 결과가 7자리가 넘을 것 같으면 
    // 처음부터 double을 사용해라.
    double d1 = 1.234567;
    double d2 = 12345.22;
    double d3 = 92345.22;
    double d4 = d1 + d2;
    double d5 = d1 + d3;
    System.out.println(d1);
    System.out.println(d2);
    System.out.println(d3);
    System.out.println(d4);     
    System.out.println(d5);
    
    
    System.out.println("\n------------------------\n");
    
    
    // 유효 자리수가 16자리 (15자리는 99퍼센트 맞음)
    // 부동 소수점에서는 100%는 없다.
    // 끝에 쓰레기값이 붙는다.
    d = 79999999.99999997;      
    System.out.println(d);
    
    
    f = 2345678912.123456f;
    //f = 2345678912.123456;     // 이미 값이 저장하기 전에 잘린다
    f = 2345678912.123456f;      // 8바이트 값을 4바이트로 만든다.
                                // 4바이트를 넘어가는 값은 자른다.
                                // 따라서 f에 들어가는 값은 잘린 값이다.
    System.out.println(f);      // 에러가 뜨진 않지만 잘린 값 출력
    
    
    d = 234.5678;
    System.out.println(d);
    
    f = 234.5678f;
    System.out.println(f);
    
    d = 234.5678f;
    System.out.println(d);      // 정수에서는 작은 값이 든 메모리에서 
                                // 더 작은 메모리로 넣었을 때 문제가 없지만 
                                //부동소수점에서는 문제가 발생한다.  
    d = f;
    System.out.println(d);
    
    // 부동 소수점 계산이 오래걸리고 복잡하기 때문에
    // CPU가 대신하여 처리한다.
    // 특히 3D프로그래밍에서는 정교한 작업으로 소수값을 필요로 하기 때문에
    // 부동소수점의 처리가 오래걸린다.
    // 연산이라는 작업을 위해 CPU가 처리하는 중에 자리가 부족하니까 
    // CPU의 층층마다 트렌지스터를 넣어 총 50억개를 넣는다.
    
    // **수정 발전기** 
    // 전기가 한 번 클럭해서 들어오면 CPU에서 한 충격으로 메모리를
    // 불러오거나 연산을 하는 기능을 함 => 시계가 틱탁해서 초를 만드는
    // 것과 같은 원리이다.
    // 이 전기가 들어오는 클럭 (crystal signal)을 세는 단위가 헤르츠이다.
    // CPU의 한 층이 한 클럭이 필요하면 12층이면 12번
    // 부동소수점에서는 이 클럭이 더 필요하다.
    // 그래픽에서도 마찬가지로 많은 클럭이 필요한데 그러다 보니
    // 열이 발생하는 문제가 생긴다.
    // 그래서 그래픽카드안에는 GPU라고 열을 식히는 팬이 들어있다.
    // 그래픽카드에는 부동소수점을 많이 처리하기 때문에 특화되어 있다.
    
    // 결론 :
    // 정수에서는 int를 long에 사이즈가 작은 long값을 int에 넣는 것이
    // 가능하지만 부동소수점 세계에서는 float을 double에 double을 float에
    // 변환시키지 말자. 그냥 웬만하면 double쓰자..

  }
}
